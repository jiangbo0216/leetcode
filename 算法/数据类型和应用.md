抽象问题，画图解决

逆向思维：递归
正向思维：迭代


## 线性表
- 数组
  - 随机访问
  - 从索引0开始，高效
  - 标记清除，提升效率
  - 插入 O(n)
  - 随机访问 O(1)
- 链表
  - 通常和hash表一起使用
  - 缓存策略
    - FIFO
    - LFU
    - LRU
  - 循环链表
  - 双向链表
  - 双向循环链表
  - 对 CPU 缓存不友好
  - 插入 O(1)
  - 随机访问 O(n)
  - 应用
    - LRU
- 栈
  - 操作受限的线性表
  - 扩容：重新申请2倍空间
  - 应用
    - 函数调用栈
    - 表达式求值
    - 括号匹配
- 队列
  - 操作受限的线性表
  - 实现
    - 数组：顺序队列
    - 链表：链式队列
  - 循环队列
  - 并发队列
  - 阻塞队列（队列为空的时候阻塞，有数据再返回，go channel）
  - 应用
    - 线程池

## 排序

稳定性，时间和空间复杂度
- 冒泡
  - 相邻元素比较，较大的或者较小的元素后移，数组最后为最大或者最小的数据
  - 实现
    - 第一层循环，变量i，[0, n)
    - 第二层循环，变量j，[0, n - i - 1)
      - j 和 j+1 位置的元素进行位置比较
  - 原地排序
  - 稳定
- 插入
  - 排序开始，把第一个元素视为有序的数组，后续的元素插入到有序数组中
  - 实现
    - 第一层循环，变量i，[1, n)
    - 第二层循环，变量j，[0, i - 1)
    - 有序区间会向右移动
  - 原地排序
  - 稳定
- 选择
  - 选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾
  - 实现
    - 每一轮循环找到最小的元素，交换已排序区间的末尾元素和最小元素
  - 不稳定
  - 原地

插入排序时间更优：交换操作总耗时就是 3*K 单位时间。而插入排序中数据移动操作只需要 K 个单位时间

- 归并
  - 实现
    - 问题分解
    - 数组合并
  - 稳定
  - 非原地O(n)
- 快速
  - 原地的话是非稳定的
  - 应用
    - O(n)内查找第K大元素




归并排序的处理过程是由下到上的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。我们前面讲过，归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。

### 线性排序
- 桶排序
  - 适用于外部排序
  - 适用于比较均匀的数据集
- 计数排序
  - 特殊的桶排序，适用于数据范围比较小的场景
- 基数排序
  - 有基数大小的关系
  - 需要使用稳定的排序算法



## 查找

- 二分
  - 实现
    - 循环退出条件
      - 注意是 low<=high，而不是 low<high。
    - mid 的取值
      - low+((high-low)>>1)
    - low 和 high 的更新
      - low=mid+1，high=mid-1
  - 应用场景
    - 数组，不能是链表
    - 有序数据
    - 数据太大不适合二分